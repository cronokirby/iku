use crate::ast::*;
use crate::lexer;

grammar;

pub AST: AST = {
  <functions:Function*> => AST {<>},
};

Function: Function = {
  "func" <name:name> "(" ")" <body:Block> => Function { name, body },
};

Block: Vec<Expr> = {
  "{" <(<Expr> ";")*> "}"
};

Expr: Expr = {
  <value:name> "(" <e:Expr> ")" => Expr::Call(value, Box::new(e)),
  <l:Litteral> => Expr::Litt(l),
  <value:name> ":=" <e:Expr> => Expr::Declare(value, Box::new(e)),
  <value:name> "=" <e:Expr> => Expr::Assign(value, Box::new(e)),
  <value:name> => Expr::Name(value),
};

Litteral: Litteral = {
  <value:int> => Litteral::I64(value),
  <value:string> => Litteral::Str(value),
};

extern {
  type Location = lexer::Location;
  type Error = lexer::LexError;

  enum lexer::Token {
    "{" => lexer::Token::OpenBrace,
    "}" => lexer::Token::CloseBrace,
    "(" => lexer::Token::OpenParens,
    ")" => lexer::Token::CloseParens,
    ";" => lexer::Token::Semicolon,
    ":=" => lexer::Token::Define,
    "=" => lexer::Token::Equals,
    "func" => lexer::Token::Func,
    name => lexer::Token::Name { value: <String> },
    int => lexer::Token::IntLitteral { value: <i64> },
    string => lexer::Token::StringLitteral { value: <String> }
  }
}