use crate::ast::*;
use crate::lexer;

grammar;

Comma<T>: Vec<T> = {
  <v:(<T> ",")*> <e: T?> => match e {
    None => v,
    Some(e) => {
      let mut v = v;
      v.push(e);
      v
    }
  }
}

pub AST: AST = {
  <functions:(<Function> ";"?)*> => AST {<>},
};

Function: Function = {
  "func" <name:name> "(" <args:Comma<name>>")" <body:Block> => Function { name, args, body },
};

Block: Vec<Expr> = {
  "{" <v:(<Expr> ";")*> <e: Expr?> "}" => match e {
    None => v,
    Some(e) => {
      let mut v = v;
      v.push(e);
      v
    }
  }
};

Expr: Expr = {
  <value:name> ":=" <e:Expr> => Expr::Declare(value, Box::new(e)),
  <value:name> "=" <e:Expr> => Expr::Assign(value, Box::new(e)),
  Expr1
}

Expr1: Expr = {
  <left:Expr2> "==" <right:Expr2> => Expr::BinOp(Op::Equal, Box::new(left), Box::new(right)),
  Expr2,
};

Expr2: Expr = {
  <left:Expr3> "<=" <right:Expr3> => Expr::BinOp(Op::Leq, Box::new(left), Box::new(right)),
  <left:Expr3> "<" <right:Expr3> => Expr::BinOp(Op::Less, Box::new(left), Box::new(right)),
  <left:Expr3> ">=" <right:Expr3> => Expr::BinOp(Op::Geq, Box::new(left), Box::new(right)),
  <left:Expr3> ">" <right:Expr3> => Expr::BinOp(Op::Greater, Box::new(left), Box::new(right)),
  Expr3
};

Expr3: Expr = {
  <value:name> "(" <args:Comma<Expr>> ")" => Expr::Call(value, args),
  <l:Litteral> => Expr::Litt(l),
  <value:name> => Expr::Name(value),
  <Block> => Expr::Block(<>),
  <ExprIfElse>,
  "(" <Expr> ")",
};

ExprIfElse: Expr = {
  "if" <cond:Expr> <left:Block> <right:("else" <ExprAfterElse>)?> => {
    let right = match right {
      None => Vec::new(),
      Some(v) => v,
    };
    Expr::IfElse(Box::new(cond), left, right)
  }
}

ExprAfterElse: Vec<Expr> = {
  <ExprIfElse> => vec![<>],
  <Block>,
}

Litteral: Litteral = {
  <value:int> => Litteral::I64(value),
  <value:string> => Litteral::Str(value),
  <value:bool> => Litteral::Bool(value),
};

extern {
  type Location = lexer::Location;
  type Error = lexer::LexError;

  enum lexer::Token {
    "{" => lexer::Token::OpenBrace,
    "}" => lexer::Token::CloseBrace,
    "(" => lexer::Token::OpenParens,
    ")" => lexer::Token::CloseParens,
    ";" => lexer::Token::Semicolon,
    ":=" => lexer::Token::Define,
    "==" => lexer::Token::DoubleEquals,
    "=" => lexer::Token::Equals,
    "<=" => lexer::Token::LessEquals,
    "<" => lexer::Token::Less,
    ">" => lexer::Token::Greater,
    ">=" => lexer::Token::GreaterEquals,
    "," => lexer::Token::Comma,
    "func" => lexer::Token::Func,
    "if" => lexer::Token::If,
    "else" => lexer::Token::Else,
    name => lexer::Token::Name { value: <String> },
    int => lexer::Token::IntLitteral { value: <i64> },
    string => lexer::Token::StringLitteral { value: <String> },
    bool => lexer::Token::BoolLitteral { value: <bool> },
  }
}