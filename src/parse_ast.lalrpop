use crate::ast::*;
use crate::lexer;

grammar;

Comma<T>: Vec<T> = {
  <v:(<T> ",")*> <e: T?> => match e {
    None => v,
    Some(e) => {
      let mut v = v;
      v.push(e);
      v
    }
  }
}

pub AST: AST = {
  <functions:(<Function> ";"?)*> => AST {<>},
};

Function: Function = {
  "func" <name:name> "(" <args:Comma<name>>")" <body:Block> => Function { name, args, body },
};

Block: Vec<Expr> = {
  "{" <(<Expr> ";")*> "}"
};

Expr: Expr = {
  <value:name> ":=" <e:Expr> => Expr::Declare(value, Box::new(e)),
  <value:name> "=" <e:Expr> => Expr::Assign(value, Box::new(e)),
  Expr1
}

Expr1: Expr = {
  <left:Expr1> "==" <right:Expr2> => Expr::BinOp(Op::Equal, Box::new(left), Box::new(right)),
  Expr2,
};

Expr2: Expr = {
  <value:name> "(" <args:Comma<Expr>> ")" => Expr::Call(value, args),
  <l:Litteral> => Expr::Litt(l),
  <value:name> => Expr::Name(value),
  <Block> => Expr::Block(<>),
  "(" <value:Expr> ")" => value
};

Litteral: Litteral = {
  <value:int> => Litteral::I64(value),
  <value:string> => Litteral::Str(value),
  <value:bool> => Litteral::Bool(value),
};

extern {
  type Location = lexer::Location;
  type Error = lexer::LexError;

  enum lexer::Token {
    "{" => lexer::Token::OpenBrace,
    "}" => lexer::Token::CloseBrace,
    "(" => lexer::Token::OpenParens,
    ")" => lexer::Token::CloseParens,
    ";" => lexer::Token::Semicolon,
    ":=" => lexer::Token::Define,
    "==" => lexer::Token::DoubleEquals,
    "=" => lexer::Token::Equals,
    "," => lexer::Token::Comma,
    "func" => lexer::Token::Func,
    name => lexer::Token::Name { value: <String> },
    int => lexer::Token::IntLitteral { value: <i64> },
    string => lexer::Token::StringLitteral { value: <String> },
    bool => lexer::Token::BoolLitteral { value: <bool> },
  }
}