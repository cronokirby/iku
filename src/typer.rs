use crate::ast::*;
use crate::scopes::Scopes;
use std::collections::HashMap;

/// Represents the type of error generated by the type checker
#[derive(Clone, Debug)]
pub struct Error {
    message: String,
}

impl From<String> for Error {
    fn from(string: String) -> Self {
        Error { message: string }
    }
}

/// The type of result we use in the type checker
pub type Result<T> = std::result::Result<T, Error>;

fn fail<T, S: Into<String>>(message: S) -> Result<T> {
    let message = message.into();
    Err(Error { message })
}

/// Represents the basic types that exist
///
/// At the moment, this only includes premium types.
#[derive(Clone, Debug, PartialEq)]
pub enum Type {
    /// Represents the primitive 64 bit signed integer type
    I64,
    /// Represents the primitive string type
    Str,
    /// Represents the primitive boolean type
    Bool,
    /// Represents a tuple type
    Tuple(Vec<Type>),
}

impl Type {
    fn from_name(name: &TypeName) -> Result<Type> {
        match name {
            TypeName::Name(t) if t == "I64" => Ok(Type::I64),
            TypeName::Name(t) if t == "String" => Ok(Type::Str),
            TypeName::Name(t) if t == "Bool" => Ok(Type::Bool),
            TypeName::Tuple(ts) => {
                let mut types = Vec::with_capacity(ts.len());
                for t in ts {
                    types.push(Self::from_name(t)?);
                }
                Ok(Type::Tuple(types))
            }
            TypeName::Name(t) => fail(format!("Unknown type {}", t)),
        }
    }
}

// The unit type
fn unit() -> Type {
    Type::Tuple(vec![])
}

/// This is used to reference functions
struct FunctionTable<'a> {
    // A mapping from name to index in this table
    indices: HashMap<String, usize>,
    // The actual functions
    functions: &'a [Function],
}

impl<'a> FunctionTable<'a> {
    fn new(ast: &'a AST) -> Self {
        let mut indices = HashMap::with_capacity(ast.functions.len());
        for (i, f) in ast.functions.iter().enumerate() {
            indices.insert(f.name.clone(), i);
        }
        FunctionTable {
            functions: &ast.functions,
            indices,
        }
    }

    fn get(&self, index: usize) -> &Function {
        &self.functions[index]
    }

    fn index_of(&self, name: &str) -> Result<usize> {
        self.indices.get(name).copied().ok_or(Error::from(format!(
            "Trying to use unknown function {}",
            name
        )))
    }
}

/// This holds the state we need when type checking
struct Typer {
    scopes: Scopes<Type>,
}

impl Typer {
    fn new() -> Self {
        Typer {
            scopes: Scopes::new(),
        }
    }

    fn type_expr(&mut self, tbl: &FunctionTable<'_>, expr: &Expr) -> Result<Type> {
        unimplemented!()
    }

    fn type_block(&mut self, tbl: &FunctionTable<'_>, block: &[Expr]) -> Result<Type> {
        for i in 0..block.len() - 1 {
            self.type_expr(tbl, &block[i])?;
        }
        block.last().map_or(Ok(unit()), |x| self.type_expr(tbl, x))
    }

    fn check_function(&mut self, tbl: &FunctionTable<'_>, f: &Function) -> Result<()> {
        let expected = f.ret.as_ref().map(Type::from_name).unwrap_or(Ok(unit()))?;
        self.scopes.enter(false);
        let actual = self.type_block(tbl, &f.body)?;
        self.scopes.exit();
        Ok(())
    }
}

/// Make sure that an AST (i.e. a program) type checks.
///
/// Nothing is returned in the case of a success, but we can then assume
/// that no incorrect operations happen in the ast
pub fn check(ast: &AST) -> Result<()> {
    let tbl = FunctionTable::new(ast);
    let mut typer = Typer::new();
    for f in tbl.functions {
        typer.check_function(&tbl, f)?;
    }
    Ok(())
}
