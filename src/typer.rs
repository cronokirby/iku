use crate::ast::*;
use std::collections::HashMap;

/// Represents the type of error generated by the type checker
pub struct Error {
    message: String,
}

impl From<String> for Error {
    fn from(string: String) -> Self {
        Error { message: string }
    }
}

/// The type of result we use in the type checker
pub type Result<T> = std::result::Result<T, Error>;

/// Represents the basic types that exist
///
/// At the moment, this only includes premium types.
pub enum Type {
    /// Represents the primitive 64 bit signed integer type
    I64,
    /// Represents the primitive string type
    Str,
    /// Represents the primitive boolean type
    Bool,
    /// Represents a tuple type
    Tuple(Vec<Type>),
}

/// Represents the type of a function.
///
/// Functions accept a certain number of arguments, of certain types,
/// and a return value
pub struct FunctionType {
    /// The type and number of the arguments
    pub args: Vec<Type>,
    /// The type of the return value
    pub ret: Vec<Type>,
}

/// This is used to reference functions
struct FunctionTable<'a> {
    // A mapping from name to index in this table
    indices: HashMap<String, usize>,
    // The actual functions
    functions: &'a [Function],
}

impl<'a> FunctionTable<'a> {
    fn get(&self, index: usize) -> &Function {
        &self.functions[index]
    }

    fn index_of(&self, name: &str) -> Result<usize> {
        self.indices.get(name).copied().ok_or(Error::from(format!(
            "Trying to use unknown function {}",
            name
        )))
    }
}

impl<'a> From<&'a AST> for FunctionTable<'a> {
    fn from(ast: &'a AST) -> Self {
        let mut indices = HashMap::with_capacity(ast.functions.len());
        for (i, f) in ast.functions.iter().enumerate() {
            indices.insert(f.name.clone(), i);
        }
        FunctionTable {
            functions: &ast.functions,
            indices,
        }
    }
}

/// Make sure that an AST (i.e. a program) type checks.
///
/// Nothing is returned in the case of a success, but we can then assume
/// that no incorrect operations happen in the ast
fn check(ast: &AST) -> Result<()> {
    unimplemented!()
}
